(function (global, factory) {
  typeof exports === 'object' && typeof module !== 'undefined' ? module.exports = factory(require('react'), require('react-spring')) :
  typeof define === 'function' && define.amd ? define(['react', 'react-spring'], factory) :
  (global['react-swipy'] = factory(global.React,null));
}(this, (function (React,reactSpring) { 'use strict';

  var React__default = 'default' in React ? React['default'] : React;

  var getDirection = function getDirection(offset) {
    return offset > 0 ? "right" : "left";
  };
  var getOffset = function getOffset(start, end) {
    return -((start - end) * 0.75);
  };
  var getEvent = function getEvent(e) {
    return e.touches ? e.touches[0] : e;
  };
  var withX = function withX(fn) {
    return function (e) {
      return fn(getEvent(e).pageX);
    };
  };
  var getLimitOffset = function getLimitOffset(limit, direction) {
    return direction === "right" ? limit : -limit;
  };
  var getOpacity = function getOpacity(offset, limit, min) {
    return 1 - (Math.abs(offset) < min ? 0 : (Math.abs(offset) - min) / Math.abs(limit - min));
  };

  function _classCallCheck(instance, Constructor) { if (!(instance instanceof Constructor)) { throw new TypeError("Cannot call a class as a function"); } }

  function _possibleConstructorReturn(self, call) { if (!self) { throw new ReferenceError("this hasn't been initialised - super() hasn't been called"); } return call && (typeof call === "object" || typeof call === "function") ? call : self; }

  function _inherits(subClass, superClass) { if (typeof superClass !== "function" && superClass !== null) { throw new TypeError("Super expression must either be null or a function, not " + typeof superClass); } subClass.prototype = Object.create(superClass && superClass.prototype, { constructor: { value: subClass, enumerable: false, writable: true, configurable: true } }); if (superClass) Object.setPrototypeOf ? Object.setPrototypeOf(subClass, superClass) : subClass.__proto__ = superClass; }

  var SWIPE_CONFIG = {
    tension: 390,
    friction: 30,
    restSpeedThreshold: 1,
    restDisplacementThreshold: 0.01,
    overshootClamping: true,
    lastVelocity: 1,
    mass: 0.1
  };

  var DEFAULT_PROPS = {
    limit: 120,
    min: 40
  };

  var INITIAL_STATE = {
    start: 0,
    offset: 0,
    forced: false,
    swiped: false,
    moving: false,
    pristine: true
  };

  var Swipeable = function (_PureComponent) {
    _inherits(Swipeable, _PureComponent);

    function Swipeable() {
      var _temp, _this, _ret;

      _classCallCheck(this, Swipeable);

      for (var _len = arguments.length, args = Array(_len), _key = 0; _key < _len; _key++) {
        args[_key] = arguments[_key];
      }

      return _ret = (_temp = (_this = _possibleConstructorReturn(this, _PureComponent.call.apply(_PureComponent, [this].concat(args))), _this), _this.state = INITIAL_STATE, _this.onDragStart = withX(function (start) {
        if (_this.state.swiped) return;

        _this.setState({ start: start, pristine: false, moving: true });
      }), _this.onDragMove = withX(function (end) {
        var _this$state = _this.state,
            start = _this$state.start,
            swiped = _this$state.swiped,
            moving = _this$state.moving;


        if (swiped || !moving) return;

        _this.setState({ offset: getOffset(start, end) });
      }), _this.onDragEnd = function () {
        var _this$state2 = _this.state,
            offset = _this$state2.offset,
            swiped = _this$state2.swiped,
            moving = _this$state2.moving;
        var limit = _this.props.limit;


        if (swiped || !moving) return;

        if (Math.abs(offset) >= limit) {
          _this.onBeforeSwipe(getDirection(offset));
        } else {
          _this.onCancelSwipe();
        }
      }, _this.onCancelSwipe = function () {
        return _this.setState({ start: 0, offset: 0, moving: false });
      }, _this.onBeforeSwipe = function (direction) {
        var onBeforeSwipe = _this.props.onBeforeSwipe;


        if (onBeforeSwipe) {
          onBeforeSwipe(function (_direction) {
            return _this.onSwipe(_direction || direction);
          }, _this.onCancelSwipe, direction);
        } else {
          _this.onSwipe(direction);
        }
      }, _this.onSwipe = function (direction) {
        var _this$props = _this.props,
            limit = _this$props.limit,
            onSwipe = _this$props.onSwipe;


        if (onSwipe) {
          onSwipe(direction);
        }

        _this.setState({
          swiped: true,
          moving: false,
          offset: getLimitOffset(limit, direction)
        });
      }, _this.onAfterSwipe = function () {
        var onAfterSwipe = _this.props.onAfterSwipe;


        _this.setState(INITIAL_STATE);

        if (onAfterSwipe) {
          onAfterSwipe();
        }
      }, _this.forceSwipe = function (direction) {
        if (_this.state.swiped) return;

        _this.setState({
          pristine: false,
          forced: true
        });

        _this.onBeforeSwipe(direction);
      }, _temp), _possibleConstructorReturn(_this, _ret);
    }

    Swipeable.prototype.componentDidMount = function componentDidMount() {
      window.addEventListener("touchmove", this.onDragMove);
      window.addEventListener("mousemove", this.onDragMove);
      window.addEventListener("touchend", this.onDragEnd);
      window.addEventListener("mouseup", this.onDragEnd);
    };

    Swipeable.prototype.componentWillUnmount = function componentWillUnmount() {
      window.removeEventListener("touchmove", this.onDragMove);
      window.removeEventListener("mousemove", this.onDragMove);
      window.removeEventListener("touchend", this.onDragEnd);
      window.removeEventListener("mouseup", this.onDragEnd);
    };

    Swipeable.prototype.render = function render() {
      var _this2 = this;

      var _state = this.state,
          offset = _state.offset,
          swiped = _state.swiped,
          pristine = _state.pristine,
          forced = _state.forced;
      var _props = this.props,
          children = _props.children,
          limit = _props.limit,
          buttons = _props.buttons,
          min = _props.min;


      return React__default.createElement(
        React.Fragment,
        null,
        React__default.createElement(
          reactSpring.Spring,
          {
            from: { offset: 0, opacity: 1 },
            to: {
              offset: offset,
              opacity: getOpacity(offset, limit, min)
            },
            onRest: function onRest() {
              return swiped && _this2.onAfterSwipe();
            },
            immediate: pristine || !forced && Math.abs(offset) >= limit,
            config: SWIPE_CONFIG
          },
          function (_ref) {
            var offset = _ref.offset,
                opacity = _ref.opacity;
            return React__default.createElement(
              "div",
              {
                style: {
                  opacity: opacity,
                  transform: "translateX(" + offset + "px) rotate(" + offset / 10 + "deg)",
                  height: "100%",
                  width: "100%"
                },
                onMouseDown: _this2.onDragStart,
                onTouchStart: _this2.onDragStart
              },
              children
            );
          }
        ),
        buttons && buttons({
          right: function right() {
            return _this2.forceSwipe("right");
          },
          left: function left() {
            return _this2.forceSwipe("left");
          }
        })
      );
    };

    return Swipeable;
  }(React.PureComponent);

  Swipeable.defaultProps = DEFAULT_PROPS;

  return Swipeable;

})));
